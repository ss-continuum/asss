

the problem:
	many modules need to keep some information for each player, or for
	each arena.

	the easiest way to do that is to statically allocate arrays up to
	some compile-time constant MAXPLAYERS or MAXARENAS.

	this wastes memory (because if there are many fewer than MAXPLAYERS
	playing, much of that space is unused). this also (obviously) limits
	the total number of players the server can support without
	recompiling. also, it makes many algorithms that have to iterate
	through player or arena arrays slower than necessary: O(MAXPLAYERS)
	instead of O(players).

	some modules that need to allocate large amounts of data partially
	solve the wasted memory problem by statically allocating only an
	array of pointers, and then allocating the large data only when
	players connect. this still wastes 4 bytes per MAXPLAYERS-players,
	and 8 bytes (malloc overhead) for each player beyond what is
	theoretically necessary.


characteristics of a solution:
	one solution would be to create a giant struct with the data that
	each module needs, allocate those structures when players connect,
	and have only one big array of pointers, which could be much larger
	without wasting space. that would solve the wasted space problem,
	but it wouldn't solve the algorithm one, and furthermore it's
	impossible because modules can be loaded at run-time.

	another: give each module a unique key and use those unique keys to
	map to their per-player storage (e.g., with a single treap per
	player). a treap node needs 16 bytes for the head, so to keep one
	int per player would require 20 bytes + malloc overhead = 28 bytes
	per player. this is seven times worse than the static array.

	from these two, we see that the overhead of whatever scheme we
	choose has to be minimal. that is, it can't malloc something
	per-player and per-module. it has to do it either per-player or
	per-module.

	if it's per-module, then it'll have to be a fixed size when
	allocated. what happens when the number of players grows past that
	fixed size?

	so per-player seems like the only alternative. so the questions are:
	how does it know how much space each module needs? what does it do
	if a module gets loaded and needs more space?

	what should the interface look like? since there's no more
	MAXPLAYERS, we're not going to be able to do iteration with a for
	loop and index, we're going to have to do everything with lists. so
	there's no reason to say the interface should return arrays.

	but a linked list node for each player for each data item is as bad
	as the treaps. assuming the link and the data are malloced
	separately, we have 16 bytes for the link node (8 for the node
	itself, 8 for overhead), then 12 for the one int plus malloc
	overhead, which comes to 28 bytes for a single int/player, again.

	so it seems we need someone to coalesce memory used by multiple
	modules into big chunks. this memory might have to be realloc()ed,
	since we might add more modules or the modules might request extra
	per-player data.

	how about this:
		a module can do
			mykey = pd->AllocPlayerData(bytes);
			pd->FreePlayerData(mykey);
		and then
			pd->LockRead();
			FOR_EACH_PLAYER_1(p, d, mykey)
			{
				// in here, p points to the PlayerData struct for the
				// player, including p->pid.
				// d points to the private data specified by mykey.
			}
			pd->UnlockRead();
		alternatively
			p = pd->GetPlayer(pid);
			d = pd->GetPlayerData(pid, mykey);
		there can be FOR_EACH_PLAYER() that doesn't do any private data,
		FOR_EACH_PLAYER_2(), etc.

	implementation:
		each playerdata struct (or maybe another list) ends with an
		extradata field. the extradata is a huge chunk of stuff. the
		keys are offsets to extradata. so:

struct PlayerData
{
	int pid;
	// ...
	// this expands:
	char extradata[0];
};

#define FOR_EACH_PLAYER_1(p, d, mykey)
	for (
			link = LLGetHead(&pd->players);
			link && ((p = link->data,
			          next = link->next,
			          d = (void*)(p->extradata + mykey)) || 1);
			link = next)

		(
			is there an easier way to make that macro, assuming we're not
			using the standard list functions?

	struct PlayerLink
	{
		struct PlayerData pdata;
		char *extradata;
		struct Player *next;
	};

			now we can do

	#define FOR_EACH_PLAYER_1(p, d, mykey)
		for (
				link = pd->players;
				link && ((p = &link->pdata,
						  next = link->next,
						  d = (void*)(link->extradata + mykey)) || 1);
				link = next)

			overall, slightly cleaner, but not much, and we lose the utilty
			of the LL functions.
		)

		the module handling this player data stuff can resize (probably
		enlarge-only) the PlayerData structs (which contain the
		extradata arrays) with a factor of 1.5 (or something like that).
		start at 1024

players:
4 1 96 1 36 4 4 1 32 4 4 8 3 16 4 302 1 24 168 1 24 4 4 4 8 2
total: 760 bytes

arenas:
52 1 8 28 24 2 1428 8 52 24 2 4 16 64 40 8 92 360 8 24 40 24
total: 2309 bytes


quick stats on memory consumption (all taken after startup with no
playes logged in and no arenas):

  PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
before making enc, login, auth, dynamic:
 8022 grel      11   0  1960 1960  1448 S     0.0  0.7   0:00 asss
after that, before new per-player/arena stuff:
 7584 grel      11   0  1708 1708  1192 S     0.0  0.6   0:00 asss
with new per-player/arena stuff:
 7085 grel       9   0  1544 1544  1192 S     0.0  0.6   0:00 asss


