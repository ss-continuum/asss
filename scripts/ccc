#!/usr/bin/env python
# ccc - a console chat client for asss
# <grelminar@yahoo.com>

import sys, time, signal, curses, socket, select


class MyWindows:
	def __init__(me):
		me.stdscr = me.twin = me.iwin = me.pwin = None


class Line:
	def __init__(me, msg, color, tm = 0):
		me.msg = msg
		me.color = color
		if tm == 0:
			me.time = time.time()
		else:
			me.time = tm

		me.lastopts = None
		me.lastres = None

	def wordbreak(me, width, showtime = 0, indent = 2):

		if me.lastopts is not (width, showtime, indent):

			def totlen(wds):
				t = len(wds)
				for w in wds:
					t += len(w)
				return t

			words = me.msg.split(' ')
			lines = []
			if showtime:
				cl= [time.strftime('[%I:%M]', time.localtime(me.time))]
			else:
				cl = []
			
			for w in words:
				# too big to fit on a line alone
				while len(w) > width:
					# grab what can fit on this line
					if cl:
						i = width - totlen(cl) - 1
					else:
						i = width
					# add to this line, start new
					cl.append(w[:i])
					lines.append(cl)
					cl = [''] * indent
					w = w[i:]
				# if it will overflow this line
				if len(w) + totlen(cl) + 1 > width:
					lines.append(cl)
					cl = [''] * indent
				# now add it
				cl.append(w)

			# append last partial line
			lines.append(cl)

			me.lastres = map(lambda wds: ' '.join(wds), lines)

		return me.lastres


class Text:
	def __init__(me):
		me.lines = []

	def addline(me, l):
		me.lines.append(l)

	def display(me, scr):
		global scrollback, showtime, indent, newcrap

		# get window size
		h, w = scr.getmaxyx()
		
		rlines = []
		# only work on the last h lines
		for l in me.lines[-(h+scrollback):]:
			rlines.extend(map(lambda ln: (ln, l.color),
				l.wordbreak(w, showtime, indent)))
		rlines.reverse()
		# go that many lines up
		if scrollback >= len(rlines):
			scrollback = len(rlines) - 1
		rlines = rlines[scrollback:]
		# and cut to the top of the window
		rlines = rlines[:h]

		# draw them
		y = h - 1
		scr.erase()
		for l, c in rlines:
			scr.addstr(y, 0, l, c)
			y = y - 1

		if scrollback == 0:
			newcrap = 0
		if newcrap:
			scr.addstr(h-1, w-5, 'more', curses.A_REVERSE)

		scr.noutrefresh()


class Edit:
	def __init__(me):
		me.line = []
		me.i = 0
		me.lastw = 0
		me.lastmax = 0

	def display(me, scr):
		h, w = scr.getmaxyx()
		me.lastw = w
		me.lastmax = w * h - 1
		scr.erase()
		for c in me.line:
			scr.addch(c)
		scr.move(me.i / w, me.i % w)
		scr.noutrefresh()

	def process(me, ch):
		if ch in [10, curses.KEY_ENTER]:
			r = ''.join(map(chr, me.line))
			me.__init__()
			return r
		elif ch == curses.KEY_BACKSPACE:
			if me.i > 0:
				me.line = me.line[:me.i-1] + me.line[me.i:]
				me.i -= 1
		elif ch == curses.KEY_DC:
			if me.i < len(me.line):
				me.line = me.line[:me.i] + me.line[me.i+1:]
		elif ch == curses.KEY_LEFT:
			if me.i > 0:
				me.i -= 1
		elif ch == curses.KEY_RIGHT:
			if me.i < len(me.line):
				me.i += 1
		elif ch == curses.KEY_UP:
			if me.i > me.lastw:
				me.i -= me.lastw
		elif ch == curses.KEY_DOWN:
			if me.i + me.lastw <= len(me.line):
				me.i += me.lastw
		elif ch in [1, curses.KEY_HOME, curses.KEY_BEG]:
			me.i = 0
		elif ch in [5, curses.KEY_END]:
			me.i = len(me.line)
		elif ch >= ord(' ') and ch < curses.KEY_MIN:
			if len(me.line) < me.lastmax:
				me.line.insert(me.i, ch)
				me.i += 1


class Player:
	def __init__(me, name, freq):
		me.name = name
		me.freq = freq


class Colors:
	def __init__(me):
		from curses import init_pair, color_pair, A_BLINK, COLORS, COLOR_PAIRS

		me.colors = COLORS
		me.pairs = COLOR_PAIRS

		if me.pairs < 16:
			raise "Not enough colors!"

		for c in range(1, 16):
			init_pair(c, c % COLORS, 0)

		me.default = color_pair(0)
		me.info = color_pair(14) | A_BLINK
		me.arena = color_pair(10) | A_BLINK
		me.pub = color_pair(15)
		me.priv = color_pair(2)
		me.rempriv = color_pair(10)
		me.freq = color_pair(11)
		me.chat = color_pair(9)
		me.mod = color_pair(12)
		me.sysop = color_pair(9) | A_BLINK



def start_curses():
	global wins

	wins.stdscr = curses.initscr()
	curses.cbreak()
	curses.noecho()
	wins.stdscr.keypad(1)
	wins.stdscr.nodelay(1)
	curses.start_color()
	init_wins()


def init_wins():
	global wins, editheight, pwidth

	h, w = wins.stdscr.getmaxyx()

	wins.twin = wins.stdscr.subwin(h-editheight-1, w-pwidth-1, 0, 0)
	wins.iwin = wins.stdscr.subwin(editheight, w, h-editheight, 0)
	wins.pwin = wins.stdscr.subwin(h-editheight-1, pwidth, 0, w-pwidth)

	wins.stdscr.erase()
	wins.stdscr.hline(h-editheight-1, 0, '-', w)
	wins.stdscr.vline(0, w-pwidth-1, '|', h-editheight-1)
	wins.stdscr.refresh()


def end_curses():
	global wins

	wins.stdscr.keypad(0)
	curses.echo()
	curses.nocbreak()
	curses.endwin()


def process_typed(line):
	global myname, colors, showtime

	if line.startswith(';'):
		# chat message
		ns = line.find(';', 1)
		if ns == -1:
			send_line("SEND:CHAT:%s" % line[1:])
			add_line("1:%s> %s" % (myname, line[1:]), colors.chat)
		else:
			send_line("SEND:CHAT:%s" % line)
			add_line("%s:%s> %s" % (line[1:ns], myname, line[ns+1:]), colors.chat)
	elif line.startswith(':'):
		# priv msg
		ns = line.find(':', 1)
		if ns != -1:
			send_line("SEND:PRIV:%s:%s" % (line[1:ns], line[ns+1:]))
			add_line("%s to %s> %s" % (myname, line[1:ns], line[ns+1:]), colors.priv)
	elif line.startswith("'") or line.startswith('//') or line.startswith('"'):
		# team chat
		pass
	elif line.startswith('\\'):
		# mod chat
		send_line("SEND:MOD:%s" % line[1:])
		add_line("%s> %s" % (myname, line[1:]), colors.mod)
	elif line.startswith('?'):
		# possible command
		cmd = line[1:].lower()
		if cmd.startswith('exit') or cmd.startswith('quit'):
			return 1
		elif cmd.startswith('showtime'):
			showtime = 1
		elif cmd.startswith('hidetime'):
			showtime = 0
		elif cmd.startswith('go '):
			send_line("GO:%s" % cmd[3:])
		else:
			send_line("SEND:PUB:%s" % line)
		add_line("%s> %s" % (myname, line), colors.default)
	else:
		# pub msg
		send_line("SEND:PUB:%s" % line)
		add_line("%s> %s" % (myname, line), colors.default)


def process_loginok(line):
	global myname
	add_line("Login ok. You are: %s" % line, 'info')
	myname = line


def process_loginbad(line):
	add_line("Bad login: %s" % line, 'info')


def process_inarena(line):
	global players, myname

	arena, freq = line.split(':')
	add_line("Entered arena: %s" % arena, 'info')

	players.clear()
	players[myname] = Player(myname, int(freq))


def process_player(line):
	global players

	name, ship, freq = line.split(':')
	add_line("Player here: %s" % name, 'info')
	players[name] = Player(name, int(freq))


def process_entering(line):
	global players

	name, ship, freq = line.split(':')
	add_line("Player entering: %s" % name, 'info')
	players[name] = Player(name, int(freq))


def process_leaving(line):
	global players

	name = line

	add_line("Player leaving: %s" % name, 'info')
	del players[name]


def process_msg(line):
	global colors

	type, rest = line.split(':', 1)
	if type == 'ARENA':
		msg = rest
		add_line(msg, colors.arena)
	elif type == 'PUB':
		name, msg = rest.split(':', 1)
		add_line('%s> %s' % (name, msg), colors.pub)
	elif type == 'PRIV':
		name, msg = rest.split(':', 1)
		add_line('%s> %s' % (name, msg), colors.priv)
	elif type == 'REMOTEPRIV':
		msg = rest
		add_line(rest, colors.rempriv)
	elif type == 'FREQ':
		name, msg = rest.split(':', 1)
		add_line('%s> %s' % (name, msg), colors.freq)
	elif type == 'CHAT':
		msg = rest
		add_line(msg, colors.chat)
	elif type == 'MOD':
		name, msg = rest.split(':', 1)
		add_line('%s> %s' % (name, msg), colors.mod)
	elif type == 'SYSOP':
		msg = rest
		add_line(msg, colors.sysop)
	else:
		add_line("Bad message subtype from server: '%s'" % type, colors.info)


dispatch = \
{
	'LOGINOK': process_loginok,
	'LOGINBAD': process_loginbad,
	'INARENA': process_inarena,
	'PLAYER': process_player,
	'ENTERING': process_entering,
	'LEAVING': process_leaving,
	'MSG': process_msg
}

def process_incoming(line):
	type, rest = line.split(':', 1)
	if dispatch.has_key(type):
		dispatch[type](rest)
	else:
		add_line("Bad message type from server: '%s'" % type, colors.info)


def send_line(line):
	global sock
	sock.sendall(line + '\n')


def add_line(line, color = None):
	global text, colors, scrollback, jumpback, newcrap
	if color == None:
		color = colors.default
	elif type(color) == type(''):
		color = getattr(colors, color)
	text.addline(Line(line, color))
	if jumpback:
		scrollback = 0
	elif scrollback > 0:
		newcrap = 1
		scrollback += 1


def display_players(scr):
	global players, colors

	h, w = scr.getmaxyx()

	names = players.keys()
	names.sort()

	y = 0
	for n in names:
		if y >= h:
			break
		scr.addstr(y, 0, n)
		y = y + 1

	scr.noutrefresh()


def main_loop():
	global wins, text, edit, sock, scrollback

	inbuf = ''

	while 1:
		# show stuff
		text.display(wins.twin)
		display_players(wins.pwin)
		edit.display(wins.iwin)
		curses.doupdate()

		# do a select
		try:
			select.select([sys.stdin, sock], [], [], 1)
		except:
			pass

		# get key
		ch = wins.stdscr.getch()
		if ch == curses.KEY_RESIZE:
			init_wins()
			curses.doupdate()
		elif ch in [curses.KEY_NPAGE]:
			if scrollback > 0:
				scrollback -= 1
		elif ch in [curses.KEY_PPAGE]:
			scrollback += 1
		else:
			ret = edit.process(ch)
			if ret:
				if process_typed(ret):
					break

		# read some data
		try:
			r = sock.recv(1024)
			if r:
				inbuf = inbuf + r
			else:
				raise "Server disconnected!"

			lines = inbuf.splitlines(1)
			inbuf = ''
			for l in lines:
				if l.endswith('\n') or l.endswith('\r'):
					process_incoming(l.strip())
				else:
					inbuf = l
			del lines

		except:
			pass


def main():
	global wins, text, edit, sock, players, myname, colors, scrollback
	global editheight, pwidth, showtime, indent, jumpback

	opts = { 'true': 1, 'false': 0, 'yes': 1, 'no': 0 }
	players = {}
	myname = ''

	# get config file
	if len(sys.argv) > 1:
		execfile(sys.argv[1], opts, opts)
	else:
		print "You must supply a configuration file."
		sys.exit(1)

	# check for required options
	if not opts.has_key('name') or not opts.has_key('password') or \
	   not opts.has_key('host') or not opts.has_key('port'):
		print "The config file must include a name, password, host, and port."
		sys.exit(2)

	editheight = opts.get('editheight', 3)
	pwidth = opts.get('playerwidth', 10)
	indent = opts.get('indent', 2)
	showtime = opts.get('showtime', 1)
	jumpback = opts.get('jumpback', 0)
	scrollback = 0

	wins = MyWindows()
	text = Text()
	edit = Edit()

	start_curses()

	try:

		colors = Colors()

		add_line("ccc - a console chat client <grelminar@yahoo.com>", 'info')
		add_line("Connecting to %s:%d as %s..." % \
			(opts['host'], opts['port'], opts['name']), 'info')
		text.display(wins.twin)
		curses.doupdate()

		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.connect((opts['host'], opts['port']))
		sock.setblocking(0)

		add_line("Logging in...", 'info')
		text.display(wins.twin)
		curses.doupdate()

		send_line("LOGIN:1:%s:%s" % (opts['name'], opts['password']))

		main_loop()

	finally:
		end_curses()


if __name__ == '__main__':
	main()

